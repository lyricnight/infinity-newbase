package club.lyric.infinity.impl.modules.exploit;

import club.lyric.infinity.api.event.bus.EventHandler;
import club.lyric.infinity.api.module.Category;
import club.lyric.infinity.api.module.ModuleBase;
import club.lyric.infinity.api.setting.settings.BooleanSetting;
import club.lyric.infinity.api.setting.settings.NumberSetting;
import club.lyric.infinity.api.util.client.chat.ChatUtils;
import club.lyric.infinity.impl.events.network.PacketEvent;
import club.lyric.infinity.manager.Managers;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.common.CommonPongC2SPacket;
import net.minecraft.network.packet.c2s.common.KeepAliveC2SPacket;
import net.minecraft.network.packet.c2s.common.ResourcePackStatusC2SPacket;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * @author lyric
 */
//TODO: figure out if this breaks some stuff ig
@SuppressWarnings("unused")
public final class PingSpoof extends ModuleBase {
    public NumberSetting delay = new NumberSetting("Delay", this, 50, 1, 5000, 10, "ms");
    public BooleanSetting alt = new BooleanSetting("Alternative", false, this);

    /**
     * map for packets
     */
    private final ConcurrentMap<Packet<?>, Long> packetMap = new ConcurrentHashMap<>();

    public PingSpoof() {
        super("PingSpoof", "Delays packets sent in order to spoof ping.", Category.Exploit);
    }

    /**
     * means we don't have to check single player status every time we receive a packet.
     */
    @Override
    public void onEnable() {
        if (mc.isInSingleplayer()) {
            ChatUtils.sendMessagePrivate("You cannot enable PingSpoof on a single-player world. Disabling...");
            disable();
        } else if (nullCheck()) {
            disable();
        }
    }

    @Override
    public void onDisable() {
        synchronized (packetMap) {
            for (Map.Entry<Packet<?>, Long> packetLongEntry : packetMap.entrySet()) {
                if (packetLongEntry.getValue() + delay.getLValue() <= System.currentTimeMillis()) {
                    sendUnsafe(packetLongEntry.getKey());
                }
            }
        }
    }


    @EventHandler
    public void onPacketSend(PacketEvent.Send event) {
        Packet<?> packet = event.getPacket();

        if (packet instanceof KeepAliveC2SPacket || alt.value() && (packet instanceof ResourcePackStatusC2SPacket || packet instanceof CommonPongC2SPacket)) {
            synchronized (packetMap) {
                if (packetMap.containsKey(packet)) {
                    packetMap.remove(packet);
                    return;
                }
                packetMap.put(packet, System.currentTimeMillis());
                event.setCancelled(true);
            }
        }
    }

    @EventHandler
    public void onPacketReceive(PacketEvent.Receive event) {
        synchronized (packetMap) {
            for (Map.Entry<Packet<?>, Long> packetLongEntry : packetMap.entrySet()) {
                if (packetLongEntry.getValue() + delay.getLValue() <= System.currentTimeMillis()) {
                    sendUnsafe(packetLongEntry.getKey());
                }
            }
        }
    }

    @Override
    public String moduleInformation() {
        return Managers.SERVER.getServerPing() + "ms";
    }
}
